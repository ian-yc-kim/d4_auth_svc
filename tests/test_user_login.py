import bcrypt

from d4_auth_svc.models.user import User


def get_hashed_password(password: str) -> str:
    return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')


def test_valid_login(client, db_session):
    # Create a user with a known password
    hashed = get_hashed_password("testpassword")
    user = User(email="test@example.com", full_name="Test User", hashed_password=hashed)
    db_session.add(user)
    db_session.commit()
    
    response = client.post("/auth/login", json={"email": "test@example.com", "password": "testpassword"})
    assert response.status_code == 200
    data = response.json()
    assert "access_token" in data
    # The token is 32 hex characters as generated by token_hex(16)
    assert len(data["access_token"]) == 32


def test_invalid_login(client, db_session):
    # Create a user with a known password
    hashed = get_hashed_password("correctpassword")
    user = User(email="invalid@example.com", full_name="Invalid Login", hashed_password=hashed)
    db_session.add(user)
    db_session.commit()
    
    response = client.post("/auth/login", json={"email": "invalid@example.com", "password": "wrongpassword"})
    assert response.status_code == 401


def test_missing_fields(client):
    # Missing the password field
    response = client.post("/auth/login", json={"email": "test@example.com"})
    assert response.status_code == 422


def test_invalid_email_format(client):
    # Invalid email format should result in a validation error
    response = client.post("/auth/login", json={"email": "notanemail", "password": "password"})
    assert response.status_code == 422
